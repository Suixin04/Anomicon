import { HashMap } from "@kit.ArkUI";
import { mockSCPs } from "../data/mockData";

// åº•éƒ¨æ ‡ç­¾æ é…ç½®æ¥å£
export interface TabClass {
  icon: ResourceStr,      // æœªé€‰ä¸­æ—¶çš„å›¾æ ‡
  icon_em: ResourceStr,   // é€‰ä¸­æ—¶çš„å›¾æ ‡
  text: string            // æ ‡ç­¾æ–‡å­—
}

// SCPé¡¹ç›®åˆ†ç±»æ ‡å‡†
export type SCPClass =
  'Safe' |     // å®‰å…¨ - éœ€æœ€ä½é™åº¦ç›‘ç®¡
  'Euclid' |   // æ¬§å‡ é‡Œå¾— - éœ€ç‰¹å®šæ”¶å®¹æªæ–½
  'Keter' |    // å…‹ç‰¹çº§ - æåº¦å±é™©éœ€æœ€é«˜ä¼˜å…ˆçº§æ”¶å®¹
  'Thaumiel' | // ç‘Ÿå§†çº§ - ç”¨äºæ”¶å®¹å…¶ä»–SCP
  'Apollyon' | // é˜¿æ³¢ç½—çº§ - æ— æ³•è¢«å®Œå…¨æ”¶å®¹
  'Explained'; // å·²è§£æ˜ - å·²è§£æ˜å¼‚å¸¸ç‰¹æ€§

// SCPé¡¹ç›®ç­‰çº§å¯¹åº”çš„é¢œè‰²æ˜ å°„è¡¨
export const colorHash = new HashMap<string, string>();
colorHash.set('Safe', '#FF10B981');
colorHash.set('Euclid', '#FFEAB308');
colorHash.set('Keter', '#FFEF4444');
colorHash.set('Thaumiel', '#FF3B82F6');
colorHash.set('Apollyon', '#FF8B5CF6');
colorHash.set('Explained', '#FF6B7280');

// SCPé¡¹ç›®ç­‰çº§å¯¹åº”çš„å›¾æ ‡æ˜ å°„è¡¨
export const iconHash = new HashMap<string, string>();
iconHash.set('Safe', 'ğŸŸ¢');
iconHash.set('Euclid', 'ğŸŸ¡');
iconHash.set('Keter', 'ğŸ”´');
iconHash.set('Thaumiel', 'ğŸ”µ');
iconHash.set('Apollyon', 'ğŸŸ£');
iconHash.set('Explained', 'âšª');

// SCPé¡¹ç›®æ¥å£å®šä¹‰
export interface SCP {
  id: string;                           // é¡¹ç›®å”¯ä¸€æ ‡è¯†
  number: string;                       // SCPç¼–å·
  title: string;                        // é¡¹ç›®æ ‡é¢˜
  objectClass: SCPClass;                // é¡¹ç›®ç­‰çº§
  image?: string;                       // é¡¹ç›®å›¾ç‰‡URL
  description: string;                  // é¡¹ç›®æè¿°
  containmentProcedures: string;        // ç‰¹æ®Šæ”¶å®¹æªæ–½
  addendum?: string;                    // é™„å½•
  interviews?: string;                  // è®¿è°ˆè®°å½•
  series: number;                       // ç³»åˆ—ç¼–å·
  dateAdded: string;                    // æ·»åŠ æ—¥æœŸ
  tags: string[];                       // æ ‡ç­¾åˆ—è¡¨
  isFavorited?: boolean;                // æ˜¯å¦å·²æ”¶è—
}

// SCPæ•…äº‹æ¥å£å®šä¹‰
export interface Tale {
  id: string;                           // æ•…äº‹å”¯ä¸€æ ‡è¯†
  title: string;                        // æ•…äº‹æ ‡é¢˜
  author: string;                       // ä½œè€…
  content: string;                      // æ•…äº‹å†…å®¹
  datePublished: string;                // å‘å¸ƒæ—¥æœŸ
  tags: string[];                       // æ ‡ç­¾åˆ—è¡¨
  relatedSCPs: string[];                // ç›¸å…³SCPé¡¹ç›®åˆ—è¡¨
  isFavorited?: boolean;                // æ˜¯å¦å·²æ”¶è—
}

// éšæœºæ•°ç±»ï¼Œç”¨äºç”Ÿæˆæ¯æ—¥æ¨èSCPé¡¹ç›®
@ObservedV2
export class RandomNum {
  // éšæœºç´¢å¼•å€¼
  @Trace randomIdx: number = Math.floor(Math.random() * mockSCPs.length)
  
  // è®¾ç½®éšæœºç´¢å¼•å€¼
  setNum(Num: number) {
    this.randomIdx = Num
  }
  
  // è·å–éšæœºç´¢å¼•å€¼
  getNum() {
    return this.randomIdx
  }
}